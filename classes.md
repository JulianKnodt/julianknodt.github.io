# Classes

I wanted to write a summary of some of the courses I've taken, as well as how I felt about them.
It might be useful as a guide to future people taking the courses, but it may also serve as a
personal reminder of what I've done. It will mostly focus on the _emotional_ aspect of these
courses, and how I felt about them. The content is more easily seen in something like a
syllabus, which is probably easier to find elsewhere.

|Name |Year|Semester|
|-----|----|------|
|Intro to Systems|1|1|
|Intro to Algorithms|1|2|
|Functional Programming|1|2|
|-----|----|------|
|Discrete Math|2|1|
|Computer Architecture|2|1|
|Intro to ML|2|2|
|Graph Theory|2|2|
|-----|----|------|
|Operating Systems|3|1|
|Distributed Systems|3|1|
|Theorem Provers|3|1|
|Independent Work|3|1|

## First Year

## Intro to Systems

This class was by far the shittiest class I've ever taken, for reasons beyond the class itself.
Before explaining my hatred, to summarize the class, it's essentially an
introduction to low-level programming (C + x86), as well as some common applications like an
allocator or doing stack overflow to read hidden values from a program.
The premise is interesting, and can be a good utility for showing students
systems programming. I don't think the content is particularly inspiring, but it will suffice to
help people be aware of what exists. I don't think that a _deep_ understanding is provided
though, since the class encourages 0 discussion. My main beef with the class is that the
professor when I took it was wholly convinced that C is a shitty, unsafe language. One of the
questions on the final exam's entire purpose was to suggest to use Java. In a _systems_
programming class, this is absolutely shitty. Yes, C is unsafe and dangerous, but it's also
blazing fast. And the lecture was intended to show that "modularity" and "abstraction" are one
of the main points of systems programming. For a standard programmar, yes, you don't care about
what's under the hood, and you shouldn't have to if you want to stay sane. But if you _are_ the
systems programmer, you should be curious about every detail, and want to know how to pop the trunk and
change shit. I feel like the professor, (and due to his influence, the teaching staff), killed
any curiosity people had in the material. Finally, the professor decided to pull the last
assignment, which was making a Unix shell, instead making *Othello*. Fuck that noise. If the
professor ever taught a class I might have taken after that, I avoided it. As this was my first
CS class, it was a fantastic intro to CS courses in Uni. As compared to self-learning the
concepts, draining and the course content does not care about the end result.

## Intro to Algorithms

I don't feel anything particularly strong about this class. A lot of people who are interested
in CS will take this class out of interest, so a lot of the content is designed to be good for
people across the board. Thus, there's a significant amount of busy work, writing down
algorithms and solving them manually every friday, pre-recorded lectures before COVID was hip.
I found this mass-served content to not be particularly interesting, and that most of the
content could be useful, but I couldn't tell at the tiem if it was or wasn't. Even in
retrospect, I'm not sure whether anything I learned was good. I also realize part of the class
was still teaching people how to program, and making people more confident in their ability to
program. One thing I'd also note about this course (and Intro to Systems), is that there is a
significant amount of hand-holding. To be specific, you can go to office hours, and they will
help you debug, figuring out what is wrong with your understanding, and helping you find bugs in
your code. I feel that this kind of hand-holding ends up getting un-learned in later classes,
where there aren't enough resources for the admin to maintain it (and they shouldn't maintain it
either). Probably, the most egregious thing is either papering over someone's understanding, or
figuring out their understanding for them. The one thing I enjoyed from the course was a
competitive aspect, since there were leaderboards. I found I could just focus on the systems
component, either adding built in parallelism, optimizing for the Java GC, using bitwise
operations, and that would be sufficient to do well (which might be antithetical to the course).
But doing shit that isn't intended is always the most fun.

## Functional Programming

I felt this class to be mostly lackluster, although it may be more useful depending on what
field of programming/research someone is focusing on. The first few assignments are mostly just
focusing on OCaML (which is a shitty language, fuck you Jane Street). That's fine, it can be
difficult to learn functional paradigms, but I think the assignments basically only taught
syntax, whereas they could've also been more compressed in terms of adding in components of
mutual recursion, continuation-passing-style, or other things. As compared to seeing Lisp, I
felt like my mind was not bent so much, although this may have been affected since I had seen
Lisp before. Other than that, we also did proofs on programs, which from a research POV may be
useful, but from a practicality perspective is pretty useless. The final assignment was
semi-interesting, since we had to do parallelized map and reduce operations in F\#, which seemed
a bit more interesting. Generally, the course is fine, but I don't know if it was necessary that
I did it. Meh, whatever.



